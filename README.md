# 3DVectorsCrossing
Требуется написать функцию Intersect, которая будет находить точку Vector3D пересечения двух
заданных на вход Segment3D. В классы Vector3D и Segment3D можно добавлять любые методы.
#### Основная идея 
Каждый отрезок можно задать параметрически как точку, зависящую от параметра, изменяющегося от 0 до 1. 
Например, для отрезка seg1 с началом 𝑃1 и концом 𝑃2 : 𝑃(𝑡) = 𝑃1 + 𝑡*(𝑃2 − 𝑃1) , 𝑡 ∈ [ 0 , 1 ].
Для второго отрезка seg2 с началом 𝑄1 и концом 𝑄2​ : 𝑄(𝑢) = 𝑄1 + 𝑢*(𝑄2 − 𝑄1) , 𝑢 ∈ [ 0 , 1 ].
Необходимо найти такие значения параметров 𝑡 и 𝑢, при которых 𝑃(𝑡) = 𝑄(𝑢). 
#### Параметрическое уравнение
Параметрическое уравнение для двух точек пересечения: 𝑃1 + 𝑡*(𝑃2 − 𝑃1) = 𝑄1 + 𝑢*(𝑄2 − 𝑄1).
Разложим это уравнение на составляющие: 𝑃1 + 𝑡𝑑1 = 𝑄1 + 𝑢𝑑2, где 𝑑1 = 𝑃2 − 𝑃1 и 𝑑2 = 𝑄2 − 𝑄1. 
#### Метод векторного произведения
- Проверка параллельности: 
Если векторное произведение 𝑑1 и 𝑑2 равно нулю, то отрезки параллельны и не пересекаются (если они не лежат на одной прямой). 
- Нахождение параметров 𝑡 и 𝑢 : 
Используем векторное произведение для нахождения точек пересечения. 
#### Алгоритм 
1. Вычисляем направляющие векторы отрезков: 𝑑1 = 𝑃2 − 𝑃1, 𝑑2 = 𝑄2 − 𝑄1;
2. Вычисляем векторное произведение направляющих векторов: 𝑐𝑟𝑜𝑠𝑠 = 𝑑1 × 𝑑2, crossLength = |𝑐𝑟𝑜𝑠𝑠|;
3. Если длина векторного произведения мала (параллельность): если crossLength < 1𝑒 − 6 то параллельны;
4. Вычисляем разницу начальных точек: 𝑑𝑖𝑓𝑓 = 𝑄1 − 𝑃1;
5. Вычисляем параметры 𝑡 и 𝑢: 𝑡 = (𝑑𝑖𝑓𝑓 * 𝑑2)*𝑐𝑟𝑜𝑠𝑠/crossLength^2, 𝑢 = (𝑑𝑖𝑓𝑓 * 𝑑1)*𝑐𝑟𝑜𝑠𝑠/crossLength^2;
6.​ Проверяем, лежат ли параметры в пределах отрезков: если 0 ≤ 𝑡 ≤ 1 и 0 ≤ 𝑢 ≤ 1 то пересекаются.
